SETUP CONTEXT

- With server-side web applications, a web browser must make a request to the server and await a response, in order to complete a task that a user has requested. 
- The wait times can be large if there is batch process triggered for an action in UI
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Current trends in JS

BUT NOW WEB BROWSERS HAVE BECOME POWERFUL.

-  They are able to handle more complicated calculations and client-side frameworks are starting to become more popular
-  The clientÂ therefore is responsible for processing and running the code locally.

Applications become faster
 - The round trips have become less
 
 MVVM (Model-View-ViewModel)
  - ADF uses MVC model pattern 
  -  JET uses a different architecture pattern called MVVM
  - MVVM is common in client-side implementations, due to its two-way data binding between the View and ViewModel, 
    meaning that any data changes in the ViewModel are sent to the UI components, and any user inputs from the UI are updated in the ViewModel
    
  - The Model is responsible for accessing the data stores using APIs
  - The View - It is the visual and interactive web page
  - The Model is responsible for holding the data, and the View is responsible for presenting the data. 
    Think of the ViewModel as the intermediate. It exposes the Model data to assist in maintaining the state of the View.
    Lot cleaner code . BUt this is again different topic.

Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PROBLEMS that came up

As javascript began to increase its role in EAs, the JS codebases increased. Many Frameworks came into picture. And to be able to use those frameworks, we use <SCRIPT> tag - the traditional way. The <SCRIPT> tag has been existent since inception of INternet.
  - So With <script> tags, you can drop in your libraries - like jQuery underscore,backbone etc
  - Problem with <script> tags. They tend to pollute the Global scope
  - The browser has all the global variables floating inside  it. If you drop more <script> , the more variables are added. THEY COLLIDE.
  
  **************************** SHOW DEMO COLLISION

The dependency order needs to be respected
  - For ex: in here - BackgroundJS needs undescoreJS needed to be loaded before it is loaded.That is a dependancy on underscore for background. So you are 
    always loading undescore before Background.
  - Another Ex : if you are working with Jquery plugins, then you need to ensure that Jquery gets loaded before plugins get loaded
  
  **************************** SHOW DEMO DEPENDANCIES
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Solutions that came up
 
  Modules are very cool, because they let you encapsulate all sorts of functionality, and expose this functionality to other JavaScript files, as libraries. They let you  create clearly separate and reusable snippets of functionality, each testable on its own.
  
  CommonJS really works well on local server because all the files in the server are local to one another. But it doesnot work  if we use browser.Tthe files are all not
  on local system. We have to make Asyn requests (like to Jquery ) to get files on the other servers. CommonJS load Sysnchrnously but doesn't work Asynchronously.
  
  We will not discuss CommonJS here but Let me show Aysn and Sync loading of files .
  
  **************************** SHOW DEMO ASYNC ans SYNC LOADING
  
 So CommonJS doesn't work in browsers  where in files are loaded Asynchronously. As an offshoot, of CommonJS, that emphasizes browser, AMD is developed.
 AMD stands for Async module def.It is spec. AMD takes a lot of what's already in CommonJS and it just adds some additional functionality to help  support some of the
 workflows that are really common  in the browser around the async file loading.
 
 There are script loaders like requireJS and CurlJS and HeadJS that implements AMD. RequireJS is probably one of the best known AMD script loader.
 
 Specs for AMD is hosted on Github. It is really short one and easy to read unlike other W3C spec whch are bit intimidating.
 
 https://auth0.com/blog/javascript-module-systems-showdown/
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  RequireJS
  
  Though we are talking about RequireJS, it is basically, specs from AMD.
  
  define() function -> This is the only  API specification mentioned in the AMD spec.(show in specs). We have define function to define modules - with an optionalID, optional Dependancies,
  and a factory function that gets run and wahtever it returns is what your module exports. So we will go through each one individually.
  -----
  id? -> Unique identifier for the module- which is just like path that you are telling to requireJS where to find  map module.
         But requireJS discourages use of module IDs. That's because , if you need to change this moduleId , say you move your module to a different location,then you need to change this module Id by hand , that can become real pain. So requireJs says, you are developing , don't worry about putting an ID and later on when optimization runs, I will put those IDs. But be aware that there are named modules. 
 -----
 dependencies? -> You can define optional list of dependancies in an ARRAY and requireJS will go and automatically inject all those dependancies into your module
         
**************************** SHOW DEFINEs FROM OJET APP - appController.js,customer.js  . There are no names for modules. I didn't work on requireJS so much to have an opinion for myself if moduleIds are good or bad. 
  
  Require.js can't do anything (including load another script) until it is loaded itself.
  
  It is common to use data-main for applications that have only a single entry point, and to put RequireJS' configuration in the module specified in data-main,
  If you do not use data-main, you must provide an entry point after loading RequireJS
