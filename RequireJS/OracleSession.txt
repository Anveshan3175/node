SETUP CONTEXT

- With server-side web applications, a web browser must make a request to the server and await a response, in order to complete a task that a user has requested. 
- The wait times can be large if there is batch process triggered for an action in UI
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Current trends in JS

BUT NOW WEB BROWSERS HAVE BECOME POWERFUL.

-  They are able to handle more complicated calculations and client-side frameworks are starting to become more popular
-  The clientÂ therefore is responsible for processing and running the code locally.

Applications become faster
 - The round trips have become less
 
 MVVM (Model-View-ViewModel)
  - ADF uses MVC model pattern 
  -  JET uses a different architecture pattern called MVVM
  - MVVM is common in client-side implementations, due to its two-way data binding between the View and ViewModel, 
    meaning that any data changes in the ViewModel are sent to the UI components, and any user inputs from the UI are updated in the ViewModel
    
  - The Model is responsible for accessing the data stores using APIs
  - The View - It is the visual and interactive web page
  - The Model is responsible for holding the data, and the View is responsible for presenting the data. 
    Think of the ViewModel as the intermediate. It exposes the Model data to assist in maintaining the state of the View.
    Lot cleaner code . BUt this is again different topic.

Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PROBLEMS that came up

As javascript began to increase its role in EAs, the JS codebases increased. Many Frameworks came into picture. And to be able to use those frameworks, we use <SCRIPT> tag - the traditional way. The <SCRIPT> tag has been existent since inception of INternet.
  - So With <script> tags, you can drop in your libraries - like jQuery underscore,backbone etc
  - Problem with <script> tags. They tend to pollute the Global scope
  - The browser has all the global variables floating inside  it. If you drop more <script> , the more variables are added. THEY COLLIDE.
  
  SHOW DEMO COLLISION

The dependency order needs to be respected
  - For ex: in here - BackgroundJS needs undescoreJS needed to be loaded before it is loaded.That is a dependancy on underscore for background. So you are 
    always loading undescore before Background.
  - Another Ex : if you are working with Jquery plugins, then you need to ensure that Jquery gets loaded before plugins get loaded
  
  SHOW DEMO DEPENDANCIES
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
  Modules are very cool, because they let you encapsulate all sorts of functionality, and expose this functionality to other JavaScript files, as libraries. They let you create clearly separate and reusable snippets of functionality, each testable on its own.
  
  Require.js can't do anything (including load another script) until it is loaded itself.
  
  It is common to use data-main for applications that have only a single entry point, and to put RequireJS' configuration in the module specified in data-main,
  If you do not use data-main, you must provide an entry point after loading RequireJS
